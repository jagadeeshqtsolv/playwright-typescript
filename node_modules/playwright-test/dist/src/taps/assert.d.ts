/// <reference types="node" />
/**
 * @typedef {import('./types.js').TypeMap} TypeMap
 */
/**
 * Assert that actual is a subset of expected.
 *
 * @example
 * ```js
 * // Supports compare functions
 * subset({ a: 1, b: 2 }, { b: 2, a: (actual) => actual === 1 })
 * ```
 *
 * @template T
 * @param {unknown} actual
 * @param {T} expected
 * @param {string} [msg]
 *
 * @returns {asserts actual is Partial<T>} - returns true if actual is a subset of expected
 */
export function subset<T>(actual: unknown, expected: T, msg?: string | undefined): asserts actual is Partial<T>;
/**
 * Expects the `string` input to match the regular expression.
 *
 * ```js
 * import assert from 'assert/strict';
 *
 * assert.match('I will fail', /pass/);
 * // AssertionError [ERR_ASSERTION]: The input did not match the regular ...
 *
 * assert.match(123, /pass/);
 * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
 *
 * assert.match('I will pass', /pass/);
 * // OK
 * ```
 *
 * If the values do not match, or if the `string` argument is of another type than`string`, an `AssertionError` is thrown with a `message` property set equal
 * to the value of the `message` parameter. If the `message` parameter is
 * undefined, a default error message is assigned. If the `message` parameter is an
 * instance of an `Error` then it will be thrown instead of the `AssertionError`.
 *
 * @since v13.6.0, v12.16.0
 *
 * @param {string} str - string to test
 * @param {RegExp} regexp - regular expression to test against
 * @param {string | Error} [message] - error message to throw if test fails
 */
export function _match(str: string, regexp: RegExp, message?: string | Error | undefined): void;
/**
 * Expects the `string` input not to match the regular expression.
 *
 * ```js
 * import assert from 'assert/strict';
 *
 * assert.doesNotMatch('I will fail', /fail/);
 * // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...
 *
 * assert.doesNotMatch(123, /pass/);
 * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
 *
 * assert.doesNotMatch('I will pass', /different/);
 * // OK
 * ```
 *
 * If the values do match, or if the `string` argument is of another type than`string`, an `AssertionError` is thrown with a `message` property set equal
 * to the value of the `message` parameter. If the `message` parameter is
 * undefined, a default error message is assigned. If the `message` parameter is an
 * instance of an `Error` then it will be thrown instead of the `AssertionError`.
 *
 * @since v13.6.0, v12.16.0
 *
 * @param {string} str - string to test
 * @param {RegExp} regexp - regular expression to test against
 * @param {string | Error} [message] - error message to throw if test fails
 */
export function _doesNotMatch(str: string, regexp: RegExp, message?: string | Error | undefined): void;
/**
 * Assert that actual is the same type as expected.
 *
 * @template {keyof TypeMap} [T= keyof TypeMap]
 * @param {any} actual
 * @param {T} expected
 * @param {string} [msg]
 *
 * @returns {asserts actual is TypeMap[T]} - returns true if actual and expected are the same type
 */
export function type<T extends keyof import("./types.js").TypeMap = keyof import("./types.js").TypeMap>(actual: any, expected: T, msg?: string | undefined): asserts actual is import("./types.js").TypeMap[T];
/**
 * Assert that actual is instance of expected.
 *
 * @template {Function} T extends Function
 * @param {any} actual
 * @param {T} expected
 * @param {string} [msg]
 *
 * @returns {asserts actual is T} - returns true if actual and expected are the same type
 */
export function instance<T extends Function>(actual: any, expected: T, msg?: string | undefined): asserts actual is T;
export const ok: typeof _assert.ok;
export const equal: typeof _assert.strictEqual;
export const notEqual: typeof _assert.notStrictEqual;
export const deepEqual: typeof _assert.deepStrictEqual;
export const notDeepEqual: typeof _assert.notDeepStrictEqual;
export const throws: typeof _assert.throws;
export const doesNotThrow: typeof _assert.doesNotThrow;
export const rejects: typeof _assert.rejects;
export const doesNotReject: typeof _assert.doesNotReject;
export const match: typeof _assert.match;
export const doesNotMatch: typeof _assert.doesNotMatch;
export const ifError: typeof _assert.ifError;
export const fail: typeof _assert.fail;
/** @type {import('./types.js').Assert} */
export const assert: import('./types.js').Assert;
export type TypeMap = import('./types.js').TypeMap;
import _assert from 'assert';
//# sourceMappingURL=assert.d.ts.map